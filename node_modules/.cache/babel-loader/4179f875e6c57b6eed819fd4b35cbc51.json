{"ast":null,"code":"import _slicedToArray from \"C:/Users/rahil/Desktop/dahsboardomar/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _defineProperty from \"C:/Users/rahil/Desktop/dahsboardomar/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _toConsumableArray from \"C:/Users/rahil/Desktop/dahsboardomar/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nimport { useGridLogger } from '../../utils/useGridLogger';\nimport { gridRowCountSelector, gridRowsLookupSelector, gridRowTreeSelector, gridRowIdsSelector, gridRowGroupingNameSelector, gridRowsIdToIdLookupSelector } from './gridRowsSelector';\nimport { GridSignature, useGridApiEventHandler } from '../../utils/useGridApiEventHandler';\nimport { useGridVisibleRows } from '../../utils/useGridVisibleRows';\nimport { gridSortedRowIdsSelector } from '../sorting/gridSortingSelector';\nimport { gridFilteredRowsLookupSelector } from '../filter/gridFilterSelector';\nimport { getTreeNodeDescendants, createRowsInternalCache, getRowsStateFromCache, getRowIdFromRowModel } from './gridRowsUtils';\nimport { useGridRegisterPipeApplier } from '../../core/pipeProcessing';\nexport var rowsStateInitializer = function rowsStateInitializer(state, props, apiRef) {\n  apiRef.current.unstable_caches.rows = createRowsInternalCache({\n    rows: props.rows,\n    getRowId: props.getRowId,\n    loading: props.loading\n  });\n  return _extends({}, state, {\n    rows: getRowsStateFromCache({\n      apiRef: apiRef,\n      previousTree: null,\n      rowCountProp: props.rowCount,\n      loadingProp: props.loading\n    })\n  });\n};\nexport var useGridRows = function useGridRows(apiRef, props) {\n  if (process.env.NODE_ENV !== 'production') {\n    try {\n      // Freeze the `rows` prop so developers have a fast failure if they try to use Array.prototype.push().\n      Object.freeze(props.rows);\n    } catch (error) {// Sometimes, it's impossible to freeze, so we give up on it.\n    }\n  }\n\n  var logger = useGridLogger(apiRef, 'useGridRows');\n  var currentPage = useGridVisibleRows(apiRef, props);\n  var lastUpdateMs = React.useRef(Date.now());\n  var timeout = React.useRef(null);\n  var getRow = React.useCallback(function (id) {\n    var _ref;\n\n    return (_ref = gridRowsLookupSelector(apiRef)[id]) != null ? _ref : null;\n  }, [apiRef]);\n  var lookup = React.useMemo(function () {\n    return currentPage.rows.reduce(function (acc, _ref2, index) {\n      var id = _ref2.id;\n      acc[id] = index;\n      return acc;\n    }, {});\n  }, [currentPage.rows]);\n  var throttledRowsChange = React.useCallback(function (newCache, throttle) {\n    var run = function run() {\n      timeout.current = null;\n      lastUpdateMs.current = Date.now();\n      apiRef.current.setState(function (state) {\n        return _extends({}, state, {\n          rows: getRowsStateFromCache({\n            apiRef: apiRef,\n            previousTree: gridRowTreeSelector(apiRef),\n            rowCountProp: props.rowCount,\n            loadingProp: props.loading\n          })\n        });\n      });\n      apiRef.current.publishEvent('rowsSet');\n      apiRef.current.forceUpdate();\n    };\n\n    if (timeout.current) {\n      clearTimeout(timeout.current);\n      timeout.current = null;\n    }\n\n    apiRef.current.unstable_caches.rows = newCache;\n\n    if (!throttle) {\n      run();\n      return;\n    }\n\n    var throttleRemainingTimeMs = props.throttleRowsMs - (Date.now() - lastUpdateMs.current);\n\n    if (throttleRemainingTimeMs > 0) {\n      timeout.current = setTimeout(run, throttleRemainingTimeMs);\n      return;\n    }\n\n    run();\n  }, [props.throttleRowsMs, props.rowCount, props.loading, apiRef]);\n  /**\n   * API METHODS\n   */\n\n  var setRows = React.useCallback(function (rows) {\n    logger.debug(\"Updating all rows, new length \".concat(rows.length));\n    throttledRowsChange(createRowsInternalCache({\n      rows: rows,\n      getRowId: props.getRowId,\n      loading: props.loading\n    }), true);\n  }, [logger, props.getRowId, props.loading, throttledRowsChange]);\n  var updateRows = React.useCallback(function (updates) {\n    if (props.signature === GridSignature.DataGrid && updates.length > 1) {\n      // TODO: Add test with direct call to `apiRef.current.updateRows` in DataGrid after enabling the `apiRef` on the free plan.\n      throw new Error([\"MUI: You can't update several rows at once in `apiRef.current.updateRows` on the DataGrid.\", 'You need to upgrade to DataGridPro or DataGridPremium component to unlock this feature.'].join('\\n'));\n    } // we remove duplicate updates. A server can batch updates, and send several updates for the same row in one fn call.\n\n\n    var uniqueUpdates = new Map();\n    updates.forEach(function (update) {\n      var id = getRowIdFromRowModel(update, props.getRowId, 'A row was provided without id when calling updateRows():');\n\n      if (uniqueUpdates.has(id)) {\n        uniqueUpdates.set(id, _extends({}, uniqueUpdates.get(id), update));\n      } else {\n        uniqueUpdates.set(id, update);\n      }\n    });\n    var deletedRowIds = [];\n    var prevCache = apiRef.current.unstable_caches.rows;\n    var newCache = {\n      rowsBeforePartialUpdates: prevCache.rowsBeforePartialUpdates,\n      loadingPropBeforePartialUpdates: prevCache.loadingPropBeforePartialUpdates,\n      idRowsLookup: _extends({}, prevCache.idRowsLookup),\n      idToIdLookup: _extends({}, prevCache.idToIdLookup),\n      ids: _toConsumableArray(prevCache.ids)\n    };\n    uniqueUpdates.forEach(function (partialRow, id) {\n      // eslint-disable-next-line no-underscore-dangle\n      if (partialRow._action === 'delete') {\n        delete newCache.idRowsLookup[id];\n        delete newCache.idToIdLookup[id];\n        deletedRowIds.push(id);\n        return;\n      }\n\n      var oldRow = apiRef.current.getRow(id);\n\n      if (!oldRow) {\n        newCache.idRowsLookup[id] = partialRow;\n        newCache.idToIdLookup[id] = id;\n        newCache.ids.push(id);\n        return;\n      }\n\n      newCache.idRowsLookup[id] = _extends({}, apiRef.current.getRow(id), partialRow);\n    });\n\n    if (deletedRowIds.length > 0) {\n      newCache.ids = newCache.ids.filter(function (id) {\n        return !deletedRowIds.includes(id);\n      });\n    }\n\n    throttledRowsChange(newCache, true);\n  }, [props.signature, props.getRowId, throttledRowsChange, apiRef]);\n  var getRowModels = React.useCallback(function () {\n    var allRows = gridRowIdsSelector(apiRef);\n    var idRowsLookup = gridRowsLookupSelector(apiRef);\n    return new Map(allRows.map(function (id) {\n      return [id, idRowsLookup[id]];\n    }));\n  }, [apiRef]);\n  var getRowsCount = React.useCallback(function () {\n    return gridRowCountSelector(apiRef);\n  }, [apiRef]);\n  var getAllRowIds = React.useCallback(function () {\n    return gridRowIdsSelector(apiRef);\n  }, [apiRef]);\n  var getRowIndexRelativeToVisibleRows = React.useCallback(function (id) {\n    return lookup[id];\n  }, [lookup]);\n  var setRowChildrenExpansion = React.useCallback(function (id, isExpanded) {\n    var currentNode = apiRef.current.getRowNode(id);\n\n    if (!currentNode) {\n      throw new Error(\"MUI: No row with id #\".concat(id, \" found\"));\n    }\n\n    var newNode = _extends({}, currentNode, {\n      childrenExpanded: isExpanded\n    });\n\n    apiRef.current.setState(function (state) {\n      return _extends({}, state, {\n        rows: _extends({}, state.rows, {\n          tree: _extends({}, state.rows.tree, _defineProperty({}, id, newNode))\n        })\n      });\n    });\n    apiRef.current.forceUpdate();\n    apiRef.current.publishEvent('rowExpansionChange', newNode);\n  }, [apiRef]);\n  var getRowNode = React.useCallback(function (id) {\n    var _gridRowTreeSelector$;\n\n    return (_gridRowTreeSelector$ = gridRowTreeSelector(apiRef)[id]) != null ? _gridRowTreeSelector$ : null;\n  }, [apiRef]);\n  var getRowGroupChildren = React.useCallback(function (_ref3) {\n    var _ref3$skipAutoGenerat = _ref3.skipAutoGeneratedRows,\n        skipAutoGeneratedRows = _ref3$skipAutoGenerat === void 0 ? true : _ref3$skipAutoGenerat,\n        groupId = _ref3.groupId,\n        applySorting = _ref3.applySorting,\n        applyFiltering = _ref3.applyFiltering;\n    var tree = gridRowTreeSelector(apiRef);\n    var children;\n\n    if (applySorting) {\n      var groupNode = tree[groupId];\n\n      if (!groupNode) {\n        return [];\n      }\n\n      var sortedRowIds = gridSortedRowIdsSelector(apiRef);\n      children = [];\n      var startIndex = sortedRowIds.findIndex(function (id) {\n        return id === groupId;\n      }) + 1;\n\n      for (var index = startIndex; index < sortedRowIds.length && tree[sortedRowIds[index]].depth > groupNode.depth; index += 1) {\n        var id = sortedRowIds[index];\n        var node = tree[id];\n\n        if (!skipAutoGeneratedRows || !node.isAutoGenerated) {\n          children.push(id);\n        }\n      }\n    } else {\n      children = getTreeNodeDescendants(tree, groupId, skipAutoGeneratedRows);\n    }\n\n    if (applyFiltering) {\n      var filteredRowsLookup = gridFilteredRowsLookupSelector(apiRef);\n      children = children.filter(function (childId) {\n        return filteredRowsLookup[childId] !== false;\n      });\n    }\n\n    return children;\n  }, [apiRef]);\n  var setRowIndex = React.useCallback(function (rowId, targetIndex) {\n    var allRows = gridRowIdsSelector(apiRef);\n    var oldIndex = allRows.findIndex(function (row) {\n      return row === rowId;\n    });\n\n    if (oldIndex === -1 || oldIndex === targetIndex) {\n      return;\n    }\n\n    logger.debug(\"Moving row \".concat(rowId, \" to index \").concat(targetIndex));\n\n    var updatedRows = _toConsumableArray(allRows);\n\n    updatedRows.splice(targetIndex, 0, updatedRows.splice(oldIndex, 1)[0]);\n    apiRef.current.setState(function (state) {\n      return _extends({}, state, {\n        rows: _extends({}, state.rows, {\n          ids: updatedRows\n        })\n      });\n    });\n    apiRef.current.publishEvent('rowsSet');\n  }, [apiRef, logger]);\n  var replaceRows = React.useCallback(function (firstRowToRender, newRows) {\n    if (props.signature === GridSignature.DataGrid && newRows.length > 1) {\n      throw new Error([\"MUI: You can't replace rows using `apiRef.current.unstable_replaceRows` on the DataGrid.\", 'You need to upgrade to DataGridPro or DataGridPremium component to unlock this feature.'].join('\\n'));\n    }\n\n    if (newRows.length === 0) {\n      return;\n    }\n\n    var allRows = gridRowIdsSelector(apiRef);\n\n    var updatedRows = _toConsumableArray(allRows);\n\n    var idRowsLookup = gridRowsLookupSelector(apiRef);\n    var idToIdLookup = gridRowsIdToIdLookupSelector(apiRef);\n    var tree = gridRowTreeSelector(apiRef);\n\n    var updatedIdRowsLookup = _extends({}, idRowsLookup);\n\n    var updatedIdToIdLookup = _extends({}, idToIdLookup);\n\n    var updatedTree = _extends({}, tree);\n\n    var newRowEntries = newRows.map(function (newRowModel) {\n      var rowId = getRowIdFromRowModel(newRowModel, props.getRowId, 'A row was provided without id when calling replaceRows().');\n      return {\n        id: rowId,\n        model: newRowModel\n      };\n    });\n    newRowEntries.forEach(function (row, index) {\n      var _updatedRows$splice = updatedRows.splice(firstRowToRender + index, 1, row.id),\n          _updatedRows$splice2 = _slicedToArray(_updatedRows$splice, 1),\n          replacedRowId = _updatedRows$splice2[0];\n\n      delete updatedIdRowsLookup[replacedRowId];\n      delete updatedIdToIdLookup[replacedRowId];\n      delete updatedTree[replacedRowId];\n    });\n    newRowEntries.forEach(function (row) {\n      var rowTreeNodeConfig = {\n        id: row.id,\n        parent: null,\n        depth: 0,\n        groupingKey: null,\n        groupingField: null\n      };\n      updatedIdRowsLookup[row.id] = row.model;\n      updatedIdToIdLookup[row.id] = row.id;\n      updatedTree[row.id] = rowTreeNodeConfig;\n    });\n    apiRef.current.setState(function (state) {\n      return _extends({}, state, {\n        rows: _extends({}, state.rows, {\n          idRowsLookup: updatedIdRowsLookup,\n          idToIdLookup: updatedIdToIdLookup,\n          tree: updatedTree,\n          ids: updatedRows\n        })\n      });\n    });\n    apiRef.current.publishEvent('rowsSet');\n  }, [apiRef, props.signature, props.getRowId]);\n  var rowApi = {\n    getRow: getRow,\n    getRowModels: getRowModels,\n    getRowsCount: getRowsCount,\n    getAllRowIds: getAllRowIds,\n    setRows: setRows,\n    setRowIndex: setRowIndex,\n    updateRows: updateRows,\n    setRowChildrenExpansion: setRowChildrenExpansion,\n    getRowNode: getRowNode,\n    getRowIndexRelativeToVisibleRows: getRowIndexRelativeToVisibleRows,\n    getRowGroupChildren: getRowGroupChildren,\n    unstable_replaceRows: replaceRows\n  };\n  /**\n   * EVENTS\n   */\n\n  var groupRows = React.useCallback(function () {\n    logger.info(\"Row grouping pre-processing have changed, regenerating the row tree\");\n    var cache;\n\n    if (apiRef.current.unstable_caches.rows.rowsBeforePartialUpdates === props.rows) {\n      // The `props.rows` did not change since the last row grouping\n      // We can use the current rows cache which contains the partial updates done recently.\n      cache = apiRef.current.unstable_caches.rows;\n    } else {\n      // The `props.rows` has changed since the last row grouping\n      // We must use the new `props.rows` on the new grouping\n      // This occurs because this event is triggered before the `useEffect` on the rows when both the grouping pre-processing and the rows changes on the same render\n      cache = createRowsInternalCache({\n        rows: props.rows,\n        getRowId: props.getRowId,\n        loading: props.loading\n      });\n    }\n\n    throttledRowsChange(cache, false);\n  }, [logger, apiRef, props.rows, props.getRowId, props.loading, throttledRowsChange]);\n  var handleStrategyProcessorChange = React.useCallback(function (methodName) {\n    if (methodName === 'rowTreeCreation') {\n      groupRows();\n    }\n  }, [groupRows]);\n  var handleStrategyActivityChange = React.useCallback(function () {\n    // `rowTreeCreation` is the only processor ran when `strategyAvailabilityChange` is fired.\n    // All the other processors listen to `rowsSet` which will be published by the `groupRows` method below.\n    if (apiRef.current.unstable_getActiveStrategy('rowTree') !== gridRowGroupingNameSelector(apiRef)) {\n      groupRows();\n    }\n  }, [apiRef, groupRows]);\n  useGridApiEventHandler(apiRef, 'activeStrategyProcessorChange', handleStrategyProcessorChange);\n  useGridApiEventHandler(apiRef, 'strategyAvailabilityChange', handleStrategyActivityChange);\n  /**\n   * APPLIERS\n   */\n\n  var applyHydrateRowsProcessor = React.useCallback(function () {\n    apiRef.current.setState(function (state) {\n      return _extends({}, state, {\n        rows: _extends({}, state.rows, apiRef.current.unstable_applyPipeProcessors('hydrateRows', state.rows.groupingResponseBeforeRowHydration))\n      });\n    });\n    apiRef.current.publishEvent('rowsSet');\n    apiRef.current.forceUpdate();\n  }, [apiRef]);\n  useGridRegisterPipeApplier(apiRef, 'hydrateRows', applyHydrateRowsProcessor);\n  useGridApiMethod(apiRef, rowApi, 'GridRowApi');\n  /**\n   * EFFECTS\n   */\n\n  React.useEffect(function () {\n    return function () {\n      if (timeout.current !== null) {\n        clearTimeout(timeout.current);\n      }\n    };\n  }, []); // The effect do not track any value defined synchronously during the 1st render by hooks called after `useGridRows`\n  // As a consequence, the state generated by the 1st run of this useEffect will always be equal to the initialization one\n\n  var isFirstRender = React.useRef(true);\n  React.useEffect(function () {\n    if (isFirstRender.current) {\n      isFirstRender.current = false;\n      return;\n    }\n\n    var areNewRowsAlreadyInState = apiRef.current.unstable_caches.rows.rowsBeforePartialUpdates === props.rows;\n    var isNewLoadingAlreadyInState = apiRef.current.unstable_caches.rows.loadingPropBeforePartialUpdates === props.loading; // The new rows have already been applied (most likely in the `'rowGroupsPreProcessingChange'` listener)\n\n    if (areNewRowsAlreadyInState) {\n      // If the loading prop has changed, we need to update its value in the state because it won't be done by `throttledRowsChange`\n      if (!isNewLoadingAlreadyInState) {\n        apiRef.current.setState(function (state) {\n          return _extends({}, state, {\n            rows: _extends({}, state.rows, {\n              loading: props.loading\n            })\n          });\n        });\n        apiRef.current.unstable_caches.rows.loadingPropBeforePartialUpdates = props.loading;\n        apiRef.current.forceUpdate();\n      }\n\n      return;\n    }\n\n    logger.debug(\"Updating all rows, new length \".concat(props.rows.length));\n    throttledRowsChange(createRowsInternalCache({\n      rows: props.rows,\n      getRowId: props.getRowId,\n      loading: props.loading\n    }), false);\n  }, [props.rows, props.rowCount, props.getRowId, props.loading, logger, throttledRowsChange, apiRef]);\n};","map":{"version":3,"names":["_extends","React","useGridApiMethod","useGridLogger","gridRowCountSelector","gridRowsLookupSelector","gridRowTreeSelector","gridRowIdsSelector","gridRowGroupingNameSelector","gridRowsIdToIdLookupSelector","GridSignature","useGridApiEventHandler","useGridVisibleRows","gridSortedRowIdsSelector","gridFilteredRowsLookupSelector","getTreeNodeDescendants","createRowsInternalCache","getRowsStateFromCache","getRowIdFromRowModel","useGridRegisterPipeApplier","rowsStateInitializer","state","props","apiRef","current","unstable_caches","rows","getRowId","loading","previousTree","rowCountProp","rowCount","loadingProp","useGridRows","process","env","NODE_ENV","Object","freeze","error","logger","currentPage","lastUpdateMs","useRef","Date","now","timeout","getRow","useCallback","id","_ref","lookup","useMemo","reduce","acc","index","throttledRowsChange","newCache","throttle","run","setState","publishEvent","forceUpdate","clearTimeout","throttleRemainingTimeMs","throttleRowsMs","setTimeout","setRows","debug","length","updateRows","updates","signature","DataGrid","Error","join","uniqueUpdates","Map","forEach","update","has","set","get","deletedRowIds","prevCache","rowsBeforePartialUpdates","loadingPropBeforePartialUpdates","idRowsLookup","idToIdLookup","ids","partialRow","_action","push","oldRow","filter","includes","getRowModels","allRows","map","getRowsCount","getAllRowIds","getRowIndexRelativeToVisibleRows","setRowChildrenExpansion","isExpanded","currentNode","getRowNode","newNode","childrenExpanded","tree","_gridRowTreeSelector$","getRowGroupChildren","skipAutoGeneratedRows","groupId","applySorting","applyFiltering","children","groupNode","sortedRowIds","startIndex","findIndex","depth","node","isAutoGenerated","filteredRowsLookup","childId","setRowIndex","rowId","targetIndex","oldIndex","row","updatedRows","splice","replaceRows","firstRowToRender","newRows","updatedIdRowsLookup","updatedIdToIdLookup","updatedTree","newRowEntries","newRowModel","model","replacedRowId","rowTreeNodeConfig","parent","groupingKey","groupingField","rowApi","unstable_replaceRows","groupRows","info","cache","handleStrategyProcessorChange","methodName","handleStrategyActivityChange","unstable_getActiveStrategy","applyHydrateRowsProcessor","unstable_applyPipeProcessors","groupingResponseBeforeRowHydration","useEffect","isFirstRender","areNewRowsAlreadyInState","isNewLoadingAlreadyInState"],"sources":["C:/Users/rahil/Desktop/dahsboardomar/node_modules/@mui/x-data-grid/hooks/features/rows/useGridRows.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nimport { useGridLogger } from '../../utils/useGridLogger';\nimport { gridRowCountSelector, gridRowsLookupSelector, gridRowTreeSelector, gridRowIdsSelector, gridRowGroupingNameSelector, gridRowsIdToIdLookupSelector } from './gridRowsSelector';\nimport { GridSignature, useGridApiEventHandler } from '../../utils/useGridApiEventHandler';\nimport { useGridVisibleRows } from '../../utils/useGridVisibleRows';\nimport { gridSortedRowIdsSelector } from '../sorting/gridSortingSelector';\nimport { gridFilteredRowsLookupSelector } from '../filter/gridFilterSelector';\nimport { getTreeNodeDescendants, createRowsInternalCache, getRowsStateFromCache, getRowIdFromRowModel } from './gridRowsUtils';\nimport { useGridRegisterPipeApplier } from '../../core/pipeProcessing';\nexport const rowsStateInitializer = (state, props, apiRef) => {\n  apiRef.current.unstable_caches.rows = createRowsInternalCache({\n    rows: props.rows,\n    getRowId: props.getRowId,\n    loading: props.loading\n  });\n  return _extends({}, state, {\n    rows: getRowsStateFromCache({\n      apiRef,\n      previousTree: null,\n      rowCountProp: props.rowCount,\n      loadingProp: props.loading\n    })\n  });\n};\nexport const useGridRows = (apiRef, props) => {\n  if (process.env.NODE_ENV !== 'production') {\n    try {\n      // Freeze the `rows` prop so developers have a fast failure if they try to use Array.prototype.push().\n      Object.freeze(props.rows);\n    } catch (error) {// Sometimes, it's impossible to freeze, so we give up on it.\n    }\n  }\n\n  const logger = useGridLogger(apiRef, 'useGridRows');\n  const currentPage = useGridVisibleRows(apiRef, props);\n  const lastUpdateMs = React.useRef(Date.now());\n  const timeout = React.useRef(null);\n  const getRow = React.useCallback(id => {\n    var _ref;\n\n    return (_ref = gridRowsLookupSelector(apiRef)[id]) != null ? _ref : null;\n  }, [apiRef]);\n  const lookup = React.useMemo(() => currentPage.rows.reduce((acc, {\n    id\n  }, index) => {\n    acc[id] = index;\n    return acc;\n  }, {}), [currentPage.rows]);\n  const throttledRowsChange = React.useCallback((newCache, throttle) => {\n    const run = () => {\n      timeout.current = null;\n      lastUpdateMs.current = Date.now();\n      apiRef.current.setState(state => _extends({}, state, {\n        rows: getRowsStateFromCache({\n          apiRef,\n          previousTree: gridRowTreeSelector(apiRef),\n          rowCountProp: props.rowCount,\n          loadingProp: props.loading\n        })\n      }));\n      apiRef.current.publishEvent('rowsSet');\n      apiRef.current.forceUpdate();\n    };\n\n    if (timeout.current) {\n      clearTimeout(timeout.current);\n      timeout.current = null;\n    }\n\n    apiRef.current.unstable_caches.rows = newCache;\n\n    if (!throttle) {\n      run();\n      return;\n    }\n\n    const throttleRemainingTimeMs = props.throttleRowsMs - (Date.now() - lastUpdateMs.current);\n\n    if (throttleRemainingTimeMs > 0) {\n      timeout.current = setTimeout(run, throttleRemainingTimeMs);\n      return;\n    }\n\n    run();\n  }, [props.throttleRowsMs, props.rowCount, props.loading, apiRef]);\n  /**\n   * API METHODS\n   */\n\n  const setRows = React.useCallback(rows => {\n    logger.debug(`Updating all rows, new length ${rows.length}`);\n    throttledRowsChange(createRowsInternalCache({\n      rows,\n      getRowId: props.getRowId,\n      loading: props.loading\n    }), true);\n  }, [logger, props.getRowId, props.loading, throttledRowsChange]);\n  const updateRows = React.useCallback(updates => {\n    if (props.signature === GridSignature.DataGrid && updates.length > 1) {\n      // TODO: Add test with direct call to `apiRef.current.updateRows` in DataGrid after enabling the `apiRef` on the free plan.\n      throw new Error([\"MUI: You can't update several rows at once in `apiRef.current.updateRows` on the DataGrid.\", 'You need to upgrade to DataGridPro or DataGridPremium component to unlock this feature.'].join('\\n'));\n    } // we remove duplicate updates. A server can batch updates, and send several updates for the same row in one fn call.\n\n\n    const uniqueUpdates = new Map();\n    updates.forEach(update => {\n      const id = getRowIdFromRowModel(update, props.getRowId, 'A row was provided without id when calling updateRows():');\n\n      if (uniqueUpdates.has(id)) {\n        uniqueUpdates.set(id, _extends({}, uniqueUpdates.get(id), update));\n      } else {\n        uniqueUpdates.set(id, update);\n      }\n    });\n    const deletedRowIds = [];\n    const prevCache = apiRef.current.unstable_caches.rows;\n    const newCache = {\n      rowsBeforePartialUpdates: prevCache.rowsBeforePartialUpdates,\n      loadingPropBeforePartialUpdates: prevCache.loadingPropBeforePartialUpdates,\n      idRowsLookup: _extends({}, prevCache.idRowsLookup),\n      idToIdLookup: _extends({}, prevCache.idToIdLookup),\n      ids: [...prevCache.ids]\n    };\n    uniqueUpdates.forEach((partialRow, id) => {\n      // eslint-disable-next-line no-underscore-dangle\n      if (partialRow._action === 'delete') {\n        delete newCache.idRowsLookup[id];\n        delete newCache.idToIdLookup[id];\n        deletedRowIds.push(id);\n        return;\n      }\n\n      const oldRow = apiRef.current.getRow(id);\n\n      if (!oldRow) {\n        newCache.idRowsLookup[id] = partialRow;\n        newCache.idToIdLookup[id] = id;\n        newCache.ids.push(id);\n        return;\n      }\n\n      newCache.idRowsLookup[id] = _extends({}, apiRef.current.getRow(id), partialRow);\n    });\n\n    if (deletedRowIds.length > 0) {\n      newCache.ids = newCache.ids.filter(id => !deletedRowIds.includes(id));\n    }\n\n    throttledRowsChange(newCache, true);\n  }, [props.signature, props.getRowId, throttledRowsChange, apiRef]);\n  const getRowModels = React.useCallback(() => {\n    const allRows = gridRowIdsSelector(apiRef);\n    const idRowsLookup = gridRowsLookupSelector(apiRef);\n    return new Map(allRows.map(id => [id, idRowsLookup[id]]));\n  }, [apiRef]);\n  const getRowsCount = React.useCallback(() => gridRowCountSelector(apiRef), [apiRef]);\n  const getAllRowIds = React.useCallback(() => gridRowIdsSelector(apiRef), [apiRef]);\n  const getRowIndexRelativeToVisibleRows = React.useCallback(id => lookup[id], [lookup]);\n  const setRowChildrenExpansion = React.useCallback((id, isExpanded) => {\n    const currentNode = apiRef.current.getRowNode(id);\n\n    if (!currentNode) {\n      throw new Error(`MUI: No row with id #${id} found`);\n    }\n\n    const newNode = _extends({}, currentNode, {\n      childrenExpanded: isExpanded\n    });\n\n    apiRef.current.setState(state => {\n      return _extends({}, state, {\n        rows: _extends({}, state.rows, {\n          tree: _extends({}, state.rows.tree, {\n            [id]: newNode\n          })\n        })\n      });\n    });\n    apiRef.current.forceUpdate();\n    apiRef.current.publishEvent('rowExpansionChange', newNode);\n  }, [apiRef]);\n  const getRowNode = React.useCallback(id => {\n    var _gridRowTreeSelector$;\n\n    return (_gridRowTreeSelector$ = gridRowTreeSelector(apiRef)[id]) != null ? _gridRowTreeSelector$ : null;\n  }, [apiRef]);\n  const getRowGroupChildren = React.useCallback(({\n    skipAutoGeneratedRows = true,\n    groupId,\n    applySorting,\n    applyFiltering\n  }) => {\n    const tree = gridRowTreeSelector(apiRef);\n    let children;\n\n    if (applySorting) {\n      const groupNode = tree[groupId];\n\n      if (!groupNode) {\n        return [];\n      }\n\n      const sortedRowIds = gridSortedRowIdsSelector(apiRef);\n      children = [];\n      const startIndex = sortedRowIds.findIndex(id => id === groupId) + 1;\n\n      for (let index = startIndex; index < sortedRowIds.length && tree[sortedRowIds[index]].depth > groupNode.depth; index += 1) {\n        const id = sortedRowIds[index];\n        const node = tree[id];\n\n        if (!skipAutoGeneratedRows || !node.isAutoGenerated) {\n          children.push(id);\n        }\n      }\n    } else {\n      children = getTreeNodeDescendants(tree, groupId, skipAutoGeneratedRows);\n    }\n\n    if (applyFiltering) {\n      const filteredRowsLookup = gridFilteredRowsLookupSelector(apiRef);\n      children = children.filter(childId => filteredRowsLookup[childId] !== false);\n    }\n\n    return children;\n  }, [apiRef]);\n  const setRowIndex = React.useCallback((rowId, targetIndex) => {\n    const allRows = gridRowIdsSelector(apiRef);\n    const oldIndex = allRows.findIndex(row => row === rowId);\n\n    if (oldIndex === -1 || oldIndex === targetIndex) {\n      return;\n    }\n\n    logger.debug(`Moving row ${rowId} to index ${targetIndex}`);\n    const updatedRows = [...allRows];\n    updatedRows.splice(targetIndex, 0, updatedRows.splice(oldIndex, 1)[0]);\n    apiRef.current.setState(state => _extends({}, state, {\n      rows: _extends({}, state.rows, {\n        ids: updatedRows\n      })\n    }));\n    apiRef.current.publishEvent('rowsSet');\n  }, [apiRef, logger]);\n  const replaceRows = React.useCallback((firstRowToRender, newRows) => {\n    if (props.signature === GridSignature.DataGrid && newRows.length > 1) {\n      throw new Error([\"MUI: You can't replace rows using `apiRef.current.unstable_replaceRows` on the DataGrid.\", 'You need to upgrade to DataGridPro or DataGridPremium component to unlock this feature.'].join('\\n'));\n    }\n\n    if (newRows.length === 0) {\n      return;\n    }\n\n    const allRows = gridRowIdsSelector(apiRef);\n    const updatedRows = [...allRows];\n    const idRowsLookup = gridRowsLookupSelector(apiRef);\n    const idToIdLookup = gridRowsIdToIdLookupSelector(apiRef);\n    const tree = gridRowTreeSelector(apiRef);\n\n    const updatedIdRowsLookup = _extends({}, idRowsLookup);\n\n    const updatedIdToIdLookup = _extends({}, idToIdLookup);\n\n    const updatedTree = _extends({}, tree);\n\n    const newRowEntries = newRows.map(newRowModel => {\n      const rowId = getRowIdFromRowModel(newRowModel, props.getRowId, 'A row was provided without id when calling replaceRows().');\n      return {\n        id: rowId,\n        model: newRowModel\n      };\n    });\n    newRowEntries.forEach((row, index) => {\n      const [replacedRowId] = updatedRows.splice(firstRowToRender + index, 1, row.id);\n      delete updatedIdRowsLookup[replacedRowId];\n      delete updatedIdToIdLookup[replacedRowId];\n      delete updatedTree[replacedRowId];\n    });\n    newRowEntries.forEach(row => {\n      const rowTreeNodeConfig = {\n        id: row.id,\n        parent: null,\n        depth: 0,\n        groupingKey: null,\n        groupingField: null\n      };\n      updatedIdRowsLookup[row.id] = row.model;\n      updatedIdToIdLookup[row.id] = row.id;\n      updatedTree[row.id] = rowTreeNodeConfig;\n    });\n    apiRef.current.setState(state => _extends({}, state, {\n      rows: _extends({}, state.rows, {\n        idRowsLookup: updatedIdRowsLookup,\n        idToIdLookup: updatedIdToIdLookup,\n        tree: updatedTree,\n        ids: updatedRows\n      })\n    }));\n    apiRef.current.publishEvent('rowsSet');\n  }, [apiRef, props.signature, props.getRowId]);\n  const rowApi = {\n    getRow,\n    getRowModels,\n    getRowsCount,\n    getAllRowIds,\n    setRows,\n    setRowIndex,\n    updateRows,\n    setRowChildrenExpansion,\n    getRowNode,\n    getRowIndexRelativeToVisibleRows,\n    getRowGroupChildren,\n    unstable_replaceRows: replaceRows\n  };\n  /**\n   * EVENTS\n   */\n\n  const groupRows = React.useCallback(() => {\n    logger.info(`Row grouping pre-processing have changed, regenerating the row tree`);\n    let cache;\n\n    if (apiRef.current.unstable_caches.rows.rowsBeforePartialUpdates === props.rows) {\n      // The `props.rows` did not change since the last row grouping\n      // We can use the current rows cache which contains the partial updates done recently.\n      cache = apiRef.current.unstable_caches.rows;\n    } else {\n      // The `props.rows` has changed since the last row grouping\n      // We must use the new `props.rows` on the new grouping\n      // This occurs because this event is triggered before the `useEffect` on the rows when both the grouping pre-processing and the rows changes on the same render\n      cache = createRowsInternalCache({\n        rows: props.rows,\n        getRowId: props.getRowId,\n        loading: props.loading\n      });\n    }\n\n    throttledRowsChange(cache, false);\n  }, [logger, apiRef, props.rows, props.getRowId, props.loading, throttledRowsChange]);\n  const handleStrategyProcessorChange = React.useCallback(methodName => {\n    if (methodName === 'rowTreeCreation') {\n      groupRows();\n    }\n  }, [groupRows]);\n  const handleStrategyActivityChange = React.useCallback(() => {\n    // `rowTreeCreation` is the only processor ran when `strategyAvailabilityChange` is fired.\n    // All the other processors listen to `rowsSet` which will be published by the `groupRows` method below.\n    if (apiRef.current.unstable_getActiveStrategy('rowTree') !== gridRowGroupingNameSelector(apiRef)) {\n      groupRows();\n    }\n  }, [apiRef, groupRows]);\n  useGridApiEventHandler(apiRef, 'activeStrategyProcessorChange', handleStrategyProcessorChange);\n  useGridApiEventHandler(apiRef, 'strategyAvailabilityChange', handleStrategyActivityChange);\n  /**\n   * APPLIERS\n   */\n\n  const applyHydrateRowsProcessor = React.useCallback(() => {\n    apiRef.current.setState(state => _extends({}, state, {\n      rows: _extends({}, state.rows, apiRef.current.unstable_applyPipeProcessors('hydrateRows', state.rows.groupingResponseBeforeRowHydration))\n    }));\n    apiRef.current.publishEvent('rowsSet');\n    apiRef.current.forceUpdate();\n  }, [apiRef]);\n  useGridRegisterPipeApplier(apiRef, 'hydrateRows', applyHydrateRowsProcessor);\n  useGridApiMethod(apiRef, rowApi, 'GridRowApi');\n  /**\n   * EFFECTS\n   */\n\n  React.useEffect(() => {\n    return () => {\n      if (timeout.current !== null) {\n        clearTimeout(timeout.current);\n      }\n    };\n  }, []); // The effect do not track any value defined synchronously during the 1st render by hooks called after `useGridRows`\n  // As a consequence, the state generated by the 1st run of this useEffect will always be equal to the initialization one\n\n  const isFirstRender = React.useRef(true);\n  React.useEffect(() => {\n    if (isFirstRender.current) {\n      isFirstRender.current = false;\n      return;\n    }\n\n    const areNewRowsAlreadyInState = apiRef.current.unstable_caches.rows.rowsBeforePartialUpdates === props.rows;\n    const isNewLoadingAlreadyInState = apiRef.current.unstable_caches.rows.loadingPropBeforePartialUpdates === props.loading; // The new rows have already been applied (most likely in the `'rowGroupsPreProcessingChange'` listener)\n\n    if (areNewRowsAlreadyInState) {\n      // If the loading prop has changed, we need to update its value in the state because it won't be done by `throttledRowsChange`\n      if (!isNewLoadingAlreadyInState) {\n        apiRef.current.setState(state => _extends({}, state, {\n          rows: _extends({}, state.rows, {\n            loading: props.loading\n          })\n        }));\n        apiRef.current.unstable_caches.rows.loadingPropBeforePartialUpdates = props.loading;\n        apiRef.current.forceUpdate();\n      }\n\n      return;\n    }\n\n    logger.debug(`Updating all rows, new length ${props.rows.length}`);\n    throttledRowsChange(createRowsInternalCache({\n      rows: props.rows,\n      getRowId: props.getRowId,\n      loading: props.loading\n    }), false);\n  }, [props.rows, props.rowCount, props.getRowId, props.loading, logger, throttledRowsChange, apiRef]);\n};"],"mappings":";;;AAAA,OAAOA,QAAP,MAAqB,oCAArB;AACA,OAAO,KAAKC,KAAZ,MAAuB,OAAvB;AACA,SAASC,gBAAT,QAAiC,8BAAjC;AACA,SAASC,aAAT,QAA8B,2BAA9B;AACA,SAASC,oBAAT,EAA+BC,sBAA/B,EAAuDC,mBAAvD,EAA4EC,kBAA5E,EAAgGC,2BAAhG,EAA6HC,4BAA7H,QAAiK,oBAAjK;AACA,SAASC,aAAT,EAAwBC,sBAAxB,QAAsD,oCAAtD;AACA,SAASC,kBAAT,QAAmC,gCAAnC;AACA,SAASC,wBAAT,QAAyC,gCAAzC;AACA,SAASC,8BAAT,QAA+C,8BAA/C;AACA,SAASC,sBAAT,EAAiCC,uBAAjC,EAA0DC,qBAA1D,EAAiFC,oBAAjF,QAA6G,iBAA7G;AACA,SAASC,0BAAT,QAA2C,2BAA3C;AACA,OAAO,IAAMC,oBAAoB,GAAG,SAAvBA,oBAAuB,CAACC,KAAD,EAAQC,KAAR,EAAeC,MAAf,EAA0B;EAC5DA,MAAM,CAACC,OAAP,CAAeC,eAAf,CAA+BC,IAA/B,GAAsCV,uBAAuB,CAAC;IAC5DU,IAAI,EAAEJ,KAAK,CAACI,IADgD;IAE5DC,QAAQ,EAAEL,KAAK,CAACK,QAF4C;IAG5DC,OAAO,EAAEN,KAAK,CAACM;EAH6C,CAAD,CAA7D;EAKA,OAAO5B,QAAQ,CAAC,EAAD,EAAKqB,KAAL,EAAY;IACzBK,IAAI,EAAET,qBAAqB,CAAC;MAC1BM,MAAM,EAANA,MAD0B;MAE1BM,YAAY,EAAE,IAFY;MAG1BC,YAAY,EAAER,KAAK,CAACS,QAHM;MAI1BC,WAAW,EAAEV,KAAK,CAACM;IAJO,CAAD;EADF,CAAZ,CAAf;AAQD,CAdM;AAeP,OAAO,IAAMK,WAAW,GAAG,SAAdA,WAAc,CAACV,MAAD,EAASD,KAAT,EAAmB;EAC5C,IAAIY,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;IACzC,IAAI;MACF;MACAC,MAAM,CAACC,MAAP,CAAchB,KAAK,CAACI,IAApB;IACD,CAHD,CAGE,OAAOa,KAAP,EAAc,CAAC;IAChB;EACF;;EAED,IAAMC,MAAM,GAAGrC,aAAa,CAACoB,MAAD,EAAS,aAAT,CAA5B;EACA,IAAMkB,WAAW,GAAG7B,kBAAkB,CAACW,MAAD,EAASD,KAAT,CAAtC;EACA,IAAMoB,YAAY,GAAGzC,KAAK,CAAC0C,MAAN,CAAaC,IAAI,CAACC,GAAL,EAAb,CAArB;EACA,IAAMC,OAAO,GAAG7C,KAAK,CAAC0C,MAAN,CAAa,IAAb,CAAhB;EACA,IAAMI,MAAM,GAAG9C,KAAK,CAAC+C,WAAN,CAAkB,UAAAC,EAAE,EAAI;IACrC,IAAIC,IAAJ;;IAEA,OAAO,CAACA,IAAI,GAAG7C,sBAAsB,CAACkB,MAAD,CAAtB,CAA+B0B,EAA/B,CAAR,KAA+C,IAA/C,GAAsDC,IAAtD,GAA6D,IAApE;EACD,CAJc,EAIZ,CAAC3B,MAAD,CAJY,CAAf;EAKA,IAAM4B,MAAM,GAAGlD,KAAK,CAACmD,OAAN,CAAc;IAAA,OAAMX,WAAW,CAACf,IAAZ,CAAiB2B,MAAjB,CAAwB,UAACC,GAAD,SAExDC,KAFwD,EAE9C;MAAA,IADXN,EACW,SADXA,EACW;MACXK,GAAG,CAACL,EAAD,CAAH,GAAUM,KAAV;MACA,OAAOD,GAAP;IACD,CALkC,EAKhC,EALgC,CAAN;EAAA,CAAd,EAKP,CAACb,WAAW,CAACf,IAAb,CALO,CAAf;EAMA,IAAM8B,mBAAmB,GAAGvD,KAAK,CAAC+C,WAAN,CAAkB,UAACS,QAAD,EAAWC,QAAX,EAAwB;IACpE,IAAMC,GAAG,GAAG,SAANA,GAAM,GAAM;MAChBb,OAAO,CAACtB,OAAR,GAAkB,IAAlB;MACAkB,YAAY,CAAClB,OAAb,GAAuBoB,IAAI,CAACC,GAAL,EAAvB;MACAtB,MAAM,CAACC,OAAP,CAAeoC,QAAf,CAAwB,UAAAvC,KAAK;QAAA,OAAIrB,QAAQ,CAAC,EAAD,EAAKqB,KAAL,EAAY;UACnDK,IAAI,EAAET,qBAAqB,CAAC;YAC1BM,MAAM,EAANA,MAD0B;YAE1BM,YAAY,EAAEvB,mBAAmB,CAACiB,MAAD,CAFP;YAG1BO,YAAY,EAAER,KAAK,CAACS,QAHM;YAI1BC,WAAW,EAAEV,KAAK,CAACM;UAJO,CAAD;QADwB,CAAZ,CAAZ;MAAA,CAA7B;MAQAL,MAAM,CAACC,OAAP,CAAeqC,YAAf,CAA4B,SAA5B;MACAtC,MAAM,CAACC,OAAP,CAAesC,WAAf;IACD,CAbD;;IAeA,IAAIhB,OAAO,CAACtB,OAAZ,EAAqB;MACnBuC,YAAY,CAACjB,OAAO,CAACtB,OAAT,CAAZ;MACAsB,OAAO,CAACtB,OAAR,GAAkB,IAAlB;IACD;;IAEDD,MAAM,CAACC,OAAP,CAAeC,eAAf,CAA+BC,IAA/B,GAAsC+B,QAAtC;;IAEA,IAAI,CAACC,QAAL,EAAe;MACbC,GAAG;MACH;IACD;;IAED,IAAMK,uBAAuB,GAAG1C,KAAK,CAAC2C,cAAN,IAAwBrB,IAAI,CAACC,GAAL,KAAaH,YAAY,CAAClB,OAAlD,CAAhC;;IAEA,IAAIwC,uBAAuB,GAAG,CAA9B,EAAiC;MAC/BlB,OAAO,CAACtB,OAAR,GAAkB0C,UAAU,CAACP,GAAD,EAAMK,uBAAN,CAA5B;MACA;IACD;;IAEDL,GAAG;EACJ,CApC2B,EAoCzB,CAACrC,KAAK,CAAC2C,cAAP,EAAuB3C,KAAK,CAACS,QAA7B,EAAuCT,KAAK,CAACM,OAA7C,EAAsDL,MAAtD,CApCyB,CAA5B;EAqCA;AACF;AACA;;EAEE,IAAM4C,OAAO,GAAGlE,KAAK,CAAC+C,WAAN,CAAkB,UAAAtB,IAAI,EAAI;IACxCc,MAAM,CAAC4B,KAAP,yCAA8C1C,IAAI,CAAC2C,MAAnD;IACAb,mBAAmB,CAACxC,uBAAuB,CAAC;MAC1CU,IAAI,EAAJA,IAD0C;MAE1CC,QAAQ,EAAEL,KAAK,CAACK,QAF0B;MAG1CC,OAAO,EAAEN,KAAK,CAACM;IAH2B,CAAD,CAAxB,EAIf,IAJe,CAAnB;EAKD,CAPe,EAOb,CAACY,MAAD,EAASlB,KAAK,CAACK,QAAf,EAAyBL,KAAK,CAACM,OAA/B,EAAwC4B,mBAAxC,CAPa,CAAhB;EAQA,IAAMc,UAAU,GAAGrE,KAAK,CAAC+C,WAAN,CAAkB,UAAAuB,OAAO,EAAI;IAC9C,IAAIjD,KAAK,CAACkD,SAAN,KAAoB9D,aAAa,CAAC+D,QAAlC,IAA8CF,OAAO,CAACF,MAAR,GAAiB,CAAnE,EAAsE;MACpE;MACA,MAAM,IAAIK,KAAJ,CAAU,CAAC,4FAAD,EAA+F,yFAA/F,EAA0LC,IAA1L,CAA+L,IAA/L,CAAV,CAAN;IACD,CAJ6C,CAI5C;;;IAGF,IAAMC,aAAa,GAAG,IAAIC,GAAJ,EAAtB;IACAN,OAAO,CAACO,OAAR,CAAgB,UAAAC,MAAM,EAAI;MACxB,IAAM9B,EAAE,GAAG/B,oBAAoB,CAAC6D,MAAD,EAASzD,KAAK,CAACK,QAAf,EAAyB,0DAAzB,CAA/B;;MAEA,IAAIiD,aAAa,CAACI,GAAd,CAAkB/B,EAAlB,CAAJ,EAA2B;QACzB2B,aAAa,CAACK,GAAd,CAAkBhC,EAAlB,EAAsBjD,QAAQ,CAAC,EAAD,EAAK4E,aAAa,CAACM,GAAd,CAAkBjC,EAAlB,CAAL,EAA4B8B,MAA5B,CAA9B;MACD,CAFD,MAEO;QACLH,aAAa,CAACK,GAAd,CAAkBhC,EAAlB,EAAsB8B,MAAtB;MACD;IACF,CARD;IASA,IAAMI,aAAa,GAAG,EAAtB;IACA,IAAMC,SAAS,GAAG7D,MAAM,CAACC,OAAP,CAAeC,eAAf,CAA+BC,IAAjD;IACA,IAAM+B,QAAQ,GAAG;MACf4B,wBAAwB,EAAED,SAAS,CAACC,wBADrB;MAEfC,+BAA+B,EAAEF,SAAS,CAACE,+BAF5B;MAGfC,YAAY,EAAEvF,QAAQ,CAAC,EAAD,EAAKoF,SAAS,CAACG,YAAf,CAHP;MAIfC,YAAY,EAAExF,QAAQ,CAAC,EAAD,EAAKoF,SAAS,CAACI,YAAf,CAJP;MAKfC,GAAG,qBAAML,SAAS,CAACK,GAAhB;IALY,CAAjB;IAOAb,aAAa,CAACE,OAAd,CAAsB,UAACY,UAAD,EAAazC,EAAb,EAAoB;MACxC;MACA,IAAIyC,UAAU,CAACC,OAAX,KAAuB,QAA3B,EAAqC;QACnC,OAAOlC,QAAQ,CAAC8B,YAAT,CAAsBtC,EAAtB,CAAP;QACA,OAAOQ,QAAQ,CAAC+B,YAAT,CAAsBvC,EAAtB,CAAP;QACAkC,aAAa,CAACS,IAAd,CAAmB3C,EAAnB;QACA;MACD;;MAED,IAAM4C,MAAM,GAAGtE,MAAM,CAACC,OAAP,CAAeuB,MAAf,CAAsBE,EAAtB,CAAf;;MAEA,IAAI,CAAC4C,MAAL,EAAa;QACXpC,QAAQ,CAAC8B,YAAT,CAAsBtC,EAAtB,IAA4ByC,UAA5B;QACAjC,QAAQ,CAAC+B,YAAT,CAAsBvC,EAAtB,IAA4BA,EAA5B;QACAQ,QAAQ,CAACgC,GAAT,CAAaG,IAAb,CAAkB3C,EAAlB;QACA;MACD;;MAEDQ,QAAQ,CAAC8B,YAAT,CAAsBtC,EAAtB,IAA4BjD,QAAQ,CAAC,EAAD,EAAKuB,MAAM,CAACC,OAAP,CAAeuB,MAAf,CAAsBE,EAAtB,CAAL,EAAgCyC,UAAhC,CAApC;IACD,CAnBD;;IAqBA,IAAIP,aAAa,CAACd,MAAd,GAAuB,CAA3B,EAA8B;MAC5BZ,QAAQ,CAACgC,GAAT,GAAehC,QAAQ,CAACgC,GAAT,CAAaK,MAAb,CAAoB,UAAA7C,EAAE;QAAA,OAAI,CAACkC,aAAa,CAACY,QAAd,CAAuB9C,EAAvB,CAAL;MAAA,CAAtB,CAAf;IACD;;IAEDO,mBAAmB,CAACC,QAAD,EAAW,IAAX,CAAnB;EACD,CApDkB,EAoDhB,CAACnC,KAAK,CAACkD,SAAP,EAAkBlD,KAAK,CAACK,QAAxB,EAAkC6B,mBAAlC,EAAuDjC,MAAvD,CApDgB,CAAnB;EAqDA,IAAMyE,YAAY,GAAG/F,KAAK,CAAC+C,WAAN,CAAkB,YAAM;IAC3C,IAAMiD,OAAO,GAAG1F,kBAAkB,CAACgB,MAAD,CAAlC;IACA,IAAMgE,YAAY,GAAGlF,sBAAsB,CAACkB,MAAD,CAA3C;IACA,OAAO,IAAIsD,GAAJ,CAAQoB,OAAO,CAACC,GAAR,CAAY,UAAAjD,EAAE;MAAA,OAAI,CAACA,EAAD,EAAKsC,YAAY,CAACtC,EAAD,CAAjB,CAAJ;IAAA,CAAd,CAAR,CAAP;EACD,CAJoB,EAIlB,CAAC1B,MAAD,CAJkB,CAArB;EAKA,IAAM4E,YAAY,GAAGlG,KAAK,CAAC+C,WAAN,CAAkB;IAAA,OAAM5C,oBAAoB,CAACmB,MAAD,CAA1B;EAAA,CAAlB,EAAsD,CAACA,MAAD,CAAtD,CAArB;EACA,IAAM6E,YAAY,GAAGnG,KAAK,CAAC+C,WAAN,CAAkB;IAAA,OAAMzC,kBAAkB,CAACgB,MAAD,CAAxB;EAAA,CAAlB,EAAoD,CAACA,MAAD,CAApD,CAArB;EACA,IAAM8E,gCAAgC,GAAGpG,KAAK,CAAC+C,WAAN,CAAkB,UAAAC,EAAE;IAAA,OAAIE,MAAM,CAACF,EAAD,CAAV;EAAA,CAApB,EAAoC,CAACE,MAAD,CAApC,CAAzC;EACA,IAAMmD,uBAAuB,GAAGrG,KAAK,CAAC+C,WAAN,CAAkB,UAACC,EAAD,EAAKsD,UAAL,EAAoB;IACpE,IAAMC,WAAW,GAAGjF,MAAM,CAACC,OAAP,CAAeiF,UAAf,CAA0BxD,EAA1B,CAApB;;IAEA,IAAI,CAACuD,WAAL,EAAkB;MAChB,MAAM,IAAI9B,KAAJ,gCAAkCzB,EAAlC,YAAN;IACD;;IAED,IAAMyD,OAAO,GAAG1G,QAAQ,CAAC,EAAD,EAAKwG,WAAL,EAAkB;MACxCG,gBAAgB,EAAEJ;IADsB,CAAlB,CAAxB;;IAIAhF,MAAM,CAACC,OAAP,CAAeoC,QAAf,CAAwB,UAAAvC,KAAK,EAAI;MAC/B,OAAOrB,QAAQ,CAAC,EAAD,EAAKqB,KAAL,EAAY;QACzBK,IAAI,EAAE1B,QAAQ,CAAC,EAAD,EAAKqB,KAAK,CAACK,IAAX,EAAiB;UAC7BkF,IAAI,EAAE5G,QAAQ,CAAC,EAAD,EAAKqB,KAAK,CAACK,IAAN,CAAWkF,IAAhB,sBACX3D,EADW,EACNyD,OADM;QADe,CAAjB;MADW,CAAZ,CAAf;IAOD,CARD;IASAnF,MAAM,CAACC,OAAP,CAAesC,WAAf;IACAvC,MAAM,CAACC,OAAP,CAAeqC,YAAf,CAA4B,oBAA5B,EAAkD6C,OAAlD;EACD,CAtB+B,EAsB7B,CAACnF,MAAD,CAtB6B,CAAhC;EAuBA,IAAMkF,UAAU,GAAGxG,KAAK,CAAC+C,WAAN,CAAkB,UAAAC,EAAE,EAAI;IACzC,IAAI4D,qBAAJ;;IAEA,OAAO,CAACA,qBAAqB,GAAGvG,mBAAmB,CAACiB,MAAD,CAAnB,CAA4B0B,EAA5B,CAAzB,KAA6D,IAA7D,GAAoE4D,qBAApE,GAA4F,IAAnG;EACD,CAJkB,EAIhB,CAACtF,MAAD,CAJgB,CAAnB;EAKA,IAAMuF,mBAAmB,GAAG7G,KAAK,CAAC+C,WAAN,CAAkB,iBAKxC;IAAA,kCAJJ+D,qBAII;IAAA,IAJJA,qBAII,sCAJoB,IAIpB;IAAA,IAHJC,OAGI,SAHJA,OAGI;IAAA,IAFJC,YAEI,SAFJA,YAEI;IAAA,IADJC,cACI,SADJA,cACI;IACJ,IAAMN,IAAI,GAAGtG,mBAAmB,CAACiB,MAAD,CAAhC;IACA,IAAI4F,QAAJ;;IAEA,IAAIF,YAAJ,EAAkB;MAChB,IAAMG,SAAS,GAAGR,IAAI,CAACI,OAAD,CAAtB;;MAEA,IAAI,CAACI,SAAL,EAAgB;QACd,OAAO,EAAP;MACD;;MAED,IAAMC,YAAY,GAAGxG,wBAAwB,CAACU,MAAD,CAA7C;MACA4F,QAAQ,GAAG,EAAX;MACA,IAAMG,UAAU,GAAGD,YAAY,CAACE,SAAb,CAAuB,UAAAtE,EAAE;QAAA,OAAIA,EAAE,KAAK+D,OAAX;MAAA,CAAzB,IAA+C,CAAlE;;MAEA,KAAK,IAAIzD,KAAK,GAAG+D,UAAjB,EAA6B/D,KAAK,GAAG8D,YAAY,CAAChD,MAArB,IAA+BuC,IAAI,CAACS,YAAY,CAAC9D,KAAD,CAAb,CAAJ,CAA0BiE,KAA1B,GAAkCJ,SAAS,CAACI,KAAxG,EAA+GjE,KAAK,IAAI,CAAxH,EAA2H;QACzH,IAAMN,EAAE,GAAGoE,YAAY,CAAC9D,KAAD,CAAvB;QACA,IAAMkE,IAAI,GAAGb,IAAI,CAAC3D,EAAD,CAAjB;;QAEA,IAAI,CAAC8D,qBAAD,IAA0B,CAACU,IAAI,CAACC,eAApC,EAAqD;UACnDP,QAAQ,CAACvB,IAAT,CAAc3C,EAAd;QACD;MACF;IACF,CAnBD,MAmBO;MACLkE,QAAQ,GAAGpG,sBAAsB,CAAC6F,IAAD,EAAOI,OAAP,EAAgBD,qBAAhB,CAAjC;IACD;;IAED,IAAIG,cAAJ,EAAoB;MAClB,IAAMS,kBAAkB,GAAG7G,8BAA8B,CAACS,MAAD,CAAzD;MACA4F,QAAQ,GAAGA,QAAQ,CAACrB,MAAT,CAAgB,UAAA8B,OAAO;QAAA,OAAID,kBAAkB,CAACC,OAAD,CAAlB,KAAgC,KAApC;MAAA,CAAvB,CAAX;IACD;;IAED,OAAOT,QAAP;EACD,CAtC2B,EAsCzB,CAAC5F,MAAD,CAtCyB,CAA5B;EAuCA,IAAMsG,WAAW,GAAG5H,KAAK,CAAC+C,WAAN,CAAkB,UAAC8E,KAAD,EAAQC,WAAR,EAAwB;IAC5D,IAAM9B,OAAO,GAAG1F,kBAAkB,CAACgB,MAAD,CAAlC;IACA,IAAMyG,QAAQ,GAAG/B,OAAO,CAACsB,SAAR,CAAkB,UAAAU,GAAG;MAAA,OAAIA,GAAG,KAAKH,KAAZ;IAAA,CAArB,CAAjB;;IAEA,IAAIE,QAAQ,KAAK,CAAC,CAAd,IAAmBA,QAAQ,KAAKD,WAApC,EAAiD;MAC/C;IACD;;IAEDvF,MAAM,CAAC4B,KAAP,sBAA2B0D,KAA3B,uBAA6CC,WAA7C;;IACA,IAAMG,WAAW,sBAAOjC,OAAP,CAAjB;;IACAiC,WAAW,CAACC,MAAZ,CAAmBJ,WAAnB,EAAgC,CAAhC,EAAmCG,WAAW,CAACC,MAAZ,CAAmBH,QAAnB,EAA6B,CAA7B,EAAgC,CAAhC,CAAnC;IACAzG,MAAM,CAACC,OAAP,CAAeoC,QAAf,CAAwB,UAAAvC,KAAK;MAAA,OAAIrB,QAAQ,CAAC,EAAD,EAAKqB,KAAL,EAAY;QACnDK,IAAI,EAAE1B,QAAQ,CAAC,EAAD,EAAKqB,KAAK,CAACK,IAAX,EAAiB;UAC7B+D,GAAG,EAAEyC;QADwB,CAAjB;MADqC,CAAZ,CAAZ;IAAA,CAA7B;IAKA3G,MAAM,CAACC,OAAP,CAAeqC,YAAf,CAA4B,SAA5B;EACD,CAjBmB,EAiBjB,CAACtC,MAAD,EAASiB,MAAT,CAjBiB,CAApB;EAkBA,IAAM4F,WAAW,GAAGnI,KAAK,CAAC+C,WAAN,CAAkB,UAACqF,gBAAD,EAAmBC,OAAnB,EAA+B;IACnE,IAAIhH,KAAK,CAACkD,SAAN,KAAoB9D,aAAa,CAAC+D,QAAlC,IAA8C6D,OAAO,CAACjE,MAAR,GAAiB,CAAnE,EAAsE;MACpE,MAAM,IAAIK,KAAJ,CAAU,CAAC,0FAAD,EAA6F,yFAA7F,EAAwLC,IAAxL,CAA6L,IAA7L,CAAV,CAAN;IACD;;IAED,IAAI2D,OAAO,CAACjE,MAAR,KAAmB,CAAvB,EAA0B;MACxB;IACD;;IAED,IAAM4B,OAAO,GAAG1F,kBAAkB,CAACgB,MAAD,CAAlC;;IACA,IAAM2G,WAAW,sBAAOjC,OAAP,CAAjB;;IACA,IAAMV,YAAY,GAAGlF,sBAAsB,CAACkB,MAAD,CAA3C;IACA,IAAMiE,YAAY,GAAG/E,4BAA4B,CAACc,MAAD,CAAjD;IACA,IAAMqF,IAAI,GAAGtG,mBAAmB,CAACiB,MAAD,CAAhC;;IAEA,IAAMgH,mBAAmB,GAAGvI,QAAQ,CAAC,EAAD,EAAKuF,YAAL,CAApC;;IAEA,IAAMiD,mBAAmB,GAAGxI,QAAQ,CAAC,EAAD,EAAKwF,YAAL,CAApC;;IAEA,IAAMiD,WAAW,GAAGzI,QAAQ,CAAC,EAAD,EAAK4G,IAAL,CAA5B;;IAEA,IAAM8B,aAAa,GAAGJ,OAAO,CAACpC,GAAR,CAAY,UAAAyC,WAAW,EAAI;MAC/C,IAAMb,KAAK,GAAG5G,oBAAoB,CAACyH,WAAD,EAAcrH,KAAK,CAACK,QAApB,EAA8B,2DAA9B,CAAlC;MACA,OAAO;QACLsB,EAAE,EAAE6E,KADC;QAELc,KAAK,EAAED;MAFF,CAAP;IAID,CANqB,CAAtB;IAOAD,aAAa,CAAC5D,OAAd,CAAsB,UAACmD,GAAD,EAAM1E,KAAN,EAAgB;MACpC,0BAAwB2E,WAAW,CAACC,MAAZ,CAAmBE,gBAAgB,GAAG9E,KAAtC,EAA6C,CAA7C,EAAgD0E,GAAG,CAAChF,EAApD,CAAxB;MAAA;MAAA,IAAO4F,aAAP;;MACA,OAAON,mBAAmB,CAACM,aAAD,CAA1B;MACA,OAAOL,mBAAmB,CAACK,aAAD,CAA1B;MACA,OAAOJ,WAAW,CAACI,aAAD,CAAlB;IACD,CALD;IAMAH,aAAa,CAAC5D,OAAd,CAAsB,UAAAmD,GAAG,EAAI;MAC3B,IAAMa,iBAAiB,GAAG;QACxB7F,EAAE,EAAEgF,GAAG,CAAChF,EADgB;QAExB8F,MAAM,EAAE,IAFgB;QAGxBvB,KAAK,EAAE,CAHiB;QAIxBwB,WAAW,EAAE,IAJW;QAKxBC,aAAa,EAAE;MALS,CAA1B;MAOAV,mBAAmB,CAACN,GAAG,CAAChF,EAAL,CAAnB,GAA8BgF,GAAG,CAACW,KAAlC;MACAJ,mBAAmB,CAACP,GAAG,CAAChF,EAAL,CAAnB,GAA8BgF,GAAG,CAAChF,EAAlC;MACAwF,WAAW,CAACR,GAAG,CAAChF,EAAL,CAAX,GAAsB6F,iBAAtB;IACD,CAXD;IAYAvH,MAAM,CAACC,OAAP,CAAeoC,QAAf,CAAwB,UAAAvC,KAAK;MAAA,OAAIrB,QAAQ,CAAC,EAAD,EAAKqB,KAAL,EAAY;QACnDK,IAAI,EAAE1B,QAAQ,CAAC,EAAD,EAAKqB,KAAK,CAACK,IAAX,EAAiB;UAC7B6D,YAAY,EAAEgD,mBADe;UAE7B/C,YAAY,EAAEgD,mBAFe;UAG7B5B,IAAI,EAAE6B,WAHuB;UAI7BhD,GAAG,EAAEyC;QAJwB,CAAjB;MADqC,CAAZ,CAAZ;IAAA,CAA7B;IAQA3G,MAAM,CAACC,OAAP,CAAeqC,YAAf,CAA4B,SAA5B;EACD,CAvDmB,EAuDjB,CAACtC,MAAD,EAASD,KAAK,CAACkD,SAAf,EAA0BlD,KAAK,CAACK,QAAhC,CAvDiB,CAApB;EAwDA,IAAMuH,MAAM,GAAG;IACbnG,MAAM,EAANA,MADa;IAEbiD,YAAY,EAAZA,YAFa;IAGbG,YAAY,EAAZA,YAHa;IAIbC,YAAY,EAAZA,YAJa;IAKbjC,OAAO,EAAPA,OALa;IAMb0D,WAAW,EAAXA,WANa;IAObvD,UAAU,EAAVA,UAPa;IAQbgC,uBAAuB,EAAvBA,uBARa;IASbG,UAAU,EAAVA,UATa;IAUbJ,gCAAgC,EAAhCA,gCAVa;IAWbS,mBAAmB,EAAnBA,mBAXa;IAYbqC,oBAAoB,EAAEf;EAZT,CAAf;EAcA;AACF;AACA;;EAEE,IAAMgB,SAAS,GAAGnJ,KAAK,CAAC+C,WAAN,CAAkB,YAAM;IACxCR,MAAM,CAAC6G,IAAP;IACA,IAAIC,KAAJ;;IAEA,IAAI/H,MAAM,CAACC,OAAP,CAAeC,eAAf,CAA+BC,IAA/B,CAAoC2D,wBAApC,KAAiE/D,KAAK,CAACI,IAA3E,EAAiF;MAC/E;MACA;MACA4H,KAAK,GAAG/H,MAAM,CAACC,OAAP,CAAeC,eAAf,CAA+BC,IAAvC;IACD,CAJD,MAIO;MACL;MACA;MACA;MACA4H,KAAK,GAAGtI,uBAAuB,CAAC;QAC9BU,IAAI,EAAEJ,KAAK,CAACI,IADkB;QAE9BC,QAAQ,EAAEL,KAAK,CAACK,QAFc;QAG9BC,OAAO,EAAEN,KAAK,CAACM;MAHe,CAAD,CAA/B;IAKD;;IAED4B,mBAAmB,CAAC8F,KAAD,EAAQ,KAAR,CAAnB;EACD,CApBiB,EAoBf,CAAC9G,MAAD,EAASjB,MAAT,EAAiBD,KAAK,CAACI,IAAvB,EAA6BJ,KAAK,CAACK,QAAnC,EAA6CL,KAAK,CAACM,OAAnD,EAA4D4B,mBAA5D,CApBe,CAAlB;EAqBA,IAAM+F,6BAA6B,GAAGtJ,KAAK,CAAC+C,WAAN,CAAkB,UAAAwG,UAAU,EAAI;IACpE,IAAIA,UAAU,KAAK,iBAAnB,EAAsC;MACpCJ,SAAS;IACV;EACF,CAJqC,EAInC,CAACA,SAAD,CAJmC,CAAtC;EAKA,IAAMK,4BAA4B,GAAGxJ,KAAK,CAAC+C,WAAN,CAAkB,YAAM;IAC3D;IACA;IACA,IAAIzB,MAAM,CAACC,OAAP,CAAekI,0BAAf,CAA0C,SAA1C,MAAyDlJ,2BAA2B,CAACe,MAAD,CAAxF,EAAkG;MAChG6H,SAAS;IACV;EACF,CANoC,EAMlC,CAAC7H,MAAD,EAAS6H,SAAT,CANkC,CAArC;EAOAzI,sBAAsB,CAACY,MAAD,EAAS,+BAAT,EAA0CgI,6BAA1C,CAAtB;EACA5I,sBAAsB,CAACY,MAAD,EAAS,4BAAT,EAAuCkI,4BAAvC,CAAtB;EACA;AACF;AACA;;EAEE,IAAME,yBAAyB,GAAG1J,KAAK,CAAC+C,WAAN,CAAkB,YAAM;IACxDzB,MAAM,CAACC,OAAP,CAAeoC,QAAf,CAAwB,UAAAvC,KAAK;MAAA,OAAIrB,QAAQ,CAAC,EAAD,EAAKqB,KAAL,EAAY;QACnDK,IAAI,EAAE1B,QAAQ,CAAC,EAAD,EAAKqB,KAAK,CAACK,IAAX,EAAiBH,MAAM,CAACC,OAAP,CAAeoI,4BAAf,CAA4C,aAA5C,EAA2DvI,KAAK,CAACK,IAAN,CAAWmI,kCAAtE,CAAjB;MADqC,CAAZ,CAAZ;IAAA,CAA7B;IAGAtI,MAAM,CAACC,OAAP,CAAeqC,YAAf,CAA4B,SAA5B;IACAtC,MAAM,CAACC,OAAP,CAAesC,WAAf;EACD,CANiC,EAM/B,CAACvC,MAAD,CAN+B,CAAlC;EAOAJ,0BAA0B,CAACI,MAAD,EAAS,aAAT,EAAwBoI,yBAAxB,CAA1B;EACAzJ,gBAAgB,CAACqB,MAAD,EAAS2H,MAAT,EAAiB,YAAjB,CAAhB;EACA;AACF;AACA;;EAEEjJ,KAAK,CAAC6J,SAAN,CAAgB,YAAM;IACpB,OAAO,YAAM;MACX,IAAIhH,OAAO,CAACtB,OAAR,KAAoB,IAAxB,EAA8B;QAC5BuC,YAAY,CAACjB,OAAO,CAACtB,OAAT,CAAZ;MACD;IACF,CAJD;EAKD,CAND,EAMG,EANH,EAzV4C,CA+VpC;EACR;;EAEA,IAAMuI,aAAa,GAAG9J,KAAK,CAAC0C,MAAN,CAAa,IAAb,CAAtB;EACA1C,KAAK,CAAC6J,SAAN,CAAgB,YAAM;IACpB,IAAIC,aAAa,CAACvI,OAAlB,EAA2B;MACzBuI,aAAa,CAACvI,OAAd,GAAwB,KAAxB;MACA;IACD;;IAED,IAAMwI,wBAAwB,GAAGzI,MAAM,CAACC,OAAP,CAAeC,eAAf,CAA+BC,IAA/B,CAAoC2D,wBAApC,KAAiE/D,KAAK,CAACI,IAAxG;IACA,IAAMuI,0BAA0B,GAAG1I,MAAM,CAACC,OAAP,CAAeC,eAAf,CAA+BC,IAA/B,CAAoC4D,+BAApC,KAAwEhE,KAAK,CAACM,OAAjH,CAPoB,CAOsG;;IAE1H,IAAIoI,wBAAJ,EAA8B;MAC5B;MACA,IAAI,CAACC,0BAAL,EAAiC;QAC/B1I,MAAM,CAACC,OAAP,CAAeoC,QAAf,CAAwB,UAAAvC,KAAK;UAAA,OAAIrB,QAAQ,CAAC,EAAD,EAAKqB,KAAL,EAAY;YACnDK,IAAI,EAAE1B,QAAQ,CAAC,EAAD,EAAKqB,KAAK,CAACK,IAAX,EAAiB;cAC7BE,OAAO,EAAEN,KAAK,CAACM;YADc,CAAjB;UADqC,CAAZ,CAAZ;QAAA,CAA7B;QAKAL,MAAM,CAACC,OAAP,CAAeC,eAAf,CAA+BC,IAA/B,CAAoC4D,+BAApC,GAAsEhE,KAAK,CAACM,OAA5E;QACAL,MAAM,CAACC,OAAP,CAAesC,WAAf;MACD;;MAED;IACD;;IAEDtB,MAAM,CAAC4B,KAAP,yCAA8C9C,KAAK,CAACI,IAAN,CAAW2C,MAAzD;IACAb,mBAAmB,CAACxC,uBAAuB,CAAC;MAC1CU,IAAI,EAAEJ,KAAK,CAACI,IAD8B;MAE1CC,QAAQ,EAAEL,KAAK,CAACK,QAF0B;MAG1CC,OAAO,EAAEN,KAAK,CAACM;IAH2B,CAAD,CAAxB,EAIf,KAJe,CAAnB;EAKD,CA9BD,EA8BG,CAACN,KAAK,CAACI,IAAP,EAAaJ,KAAK,CAACS,QAAnB,EAA6BT,KAAK,CAACK,QAAnC,EAA6CL,KAAK,CAACM,OAAnD,EAA4DY,MAA5D,EAAoEgB,mBAApE,EAAyFjC,MAAzF,CA9BH;AA+BD,CAlYM"},"metadata":{},"sourceType":"module"}